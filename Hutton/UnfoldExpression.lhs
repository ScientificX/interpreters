\section{Unfold For Expressions}

Module |UnfoldForExpressions| presents a Haskell encoding of
Hutton's interpreter and definition of fold over expressions:

\begin{code}
  module UnfoldForExpressions where
\end{code}

\begin{code}
  data (Show a,Eq a) => Expr a
      = Val a
      | Add (Expr a) (Expr a)
	deriving (Eq,Show)
\end{code}

The translation function is interesting as it almost directly
implements the operational semantics rules defined for expressions and
exhibits why it is an unfold.  What |trans| does is takes an
expression and generates a list of possible transformations of that
expression.  Because the semantics of |Add| don't specify whether the
first or second argument is evaluated first, there are two possible
paths.  Thus, |trans| is effectively a one-step unfold.

\begin{code}
  trans :: Expr Int -> [Expr Int]
  trans (Val n) = []
  trans (Add (Val n) (Val m)) = [Val (n+m)]
  trans (Add x y)
	= [Add x' y | x' <- trans x] ++
	  [Add x y' | y' <- trans y]
\end{code}

Hutton now defines |exec| as a function that applies |trans|
repeatedly until nothing remains to be translated.  The result is a
tree whose nodes are the results of applying |trans| to their
immediate predecessor in the tree.  So, each list generated by |trans|
is treated as the data associated with a set of sub-nodes.  To
represent this, we'll generate a tree.  First, define a data type for
a tree with arbitrary subtrees:

\begin{code}
  data Tree a = Node a [Tree a] deriving Show
\end{code}

Now |exec| can be defined recursively using list comprehension.
Executing |e| is |e| itself in a node with the possible translations
of |e|.  Because |exec| is referenced recursively in the list
comprehension, it will be applied to the results of each application
of |trans|.  This is a very powerful and interesting application of
\texttt{Haskell}'s list comprehension operator!

\begin{code}
  exec :: Expr Int -> Tree (Expr Int)
  exec e = Node e [exec e' | e' <- trans e]
\end{code}

Hutton abstracts from the case for |exec| by defining a function,
|oper|, that defines the operational semantics for a tree structure
using arbitrary functions for |id| and |trans| as they appear in
|exec|.  Note that |id| does not explicitly appear, but is implicitly
called on the input argument.  |oper| as defined in Hutton will not
typecheck because |f| and |g| are free.  Here is a definition for
|oper| that will type check and function appropriately:

\begin{code}
  oper f g x = Node (f x) [oper f g x' | x' <- g x]
\end{code}

If we replace |oper| with |unfold|, we get a general unfold operation for
trees of any type:

\begin{code}
  unfold f g x = Node (f x) [unfold f g x' | x' <- g x]
\end{code}

and we an redefine |oper| as |oper1|:

\begin{code}
  oper1 = unfold id trans
\end{code}

Following are some test cases for |trans|, |eval|, |oper| and |oper1|

\begin{code}
  test0 :: Expr Int
  test0 = (Add (Val 1) (Val 2))
  test1 :: Expr Int
  test1 = (Add (Add (Val 1) (Val 2)) (Val 3))
  test2 :: Expr Int
  test2 = (Add (Add (Val 1) (Val 2)) (Add (Val 3) (Val 4)))
\end{code}

