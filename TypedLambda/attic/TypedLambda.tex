\documentclass[10pt]{article}

\usepackage{haskell}
\usepackage{proof}
\usepackage{fullpage}

\parskip=\medskipamount
\parindent=0pt

\newcommand{\isa}{\ensuremath{\; {:}{:}{=} \;}}
\newcommand{\ora}{\ensuremath{\;\mid\;}}
\newcommand{\IF}{\ensuremath{\mathtt{ if \;}}}
\newcommand{\THEN}{\ensuremath{\mathtt{\; then \;}}}
\newcommand{\ELSE}{\ensuremath{\mathtt{\; else \;}}}
\newcommand{\TRUE}{\ensuremath{\mathtt{ true \;}}}
\newcommand{\FALSE}{\ensuremath{\mathtt{\; false \;}}}
\newcommand{\BOOL}{\ensuremath{\mathtt{\; Bool \;}}}

\title{EECS 762 - Project 2 Solution}
\author{Perry Alexander \\
  The University of Kansas EECS Department\\
  \texttt{alex@ittc.ku.edu}}

\begin{document}

\maketitle

\section{Introduction}

The objective of Project 2 was to write an interpreter for simply
typed lambda calculus ($\lambda_\rightarrow$) expressions as defined
in \emph{Types and Programming Languages}~\cite{Pie00}, Chapter 8,
Figure 8-1 and Chapter 9, Figure 9-1.  The definition of the abstract
syntax provides the following three forms for $\lambda_\rightarrow$
terms, values and types in:

\begin{eqnarray*}
  t & \isa & x \ora \lambda x:T.t \ora t\; t \\
  v & \isa & \lambda x:T.t \\
  T & \isa & \BOOL \ora T \rightarrow T
\end{eqnarray*}

The definition for call-by-value evaluation provides the following
six evaluation rules that will define the evaluation function:

\[\vcenter{\infer[\textsc{E-App1}]{t_1 t_2 \longrightarrow t_1^{'} t_2}{t_1\longrightarrow t_1^{'}}}\]

\[\vcenter{\infer[\textsc{E-App2}]{t_1 t_2 \longrightarrow t_1 t_2^{'}}{t_2\longrightarrow t_2^{'}}}\]

\[\vcenter{\infer[\textsc{E-AppAbs}]{(\lambda x:T.t_{12})v_2 \longrightarrow [x\rightarrow v_2]t_{12}}{}}\]

\[\vcenter{\infer[\textsc{E-IfTrue}]{t_2}{\IF \TRUE \THEN t_2 \ELSE t_3}}\]

\[\vcenter{\infer[\textsc{E-IfFalse}]{t_3}{\IF \FALSE \THEN t_2 \ELSE t_3}}\]

\[\vcenter{\infer[\textsc{E-If}]
  {\IF t_1 \THEN t_2 \ELSE t_3 \rightarrow \IF t_1^{'} \THEN t_2 \ELSE t_3}
  {t\rightarrow t_1^{'}}}
\]

Finally, the definition provides the following typing rules that will
define the type inference function:

\[\vcenter{\infer[\textsc{T-Var}]{\Gamma\vdash x:T}{x:T\in\Gamma}}\]

\[\vcenter{\infer[\textsc{T-Abs}]
  {\Gamma\vdash\lambda x:T_1.t_2 : T_1\rightarrow T_2}
  {\Gamma,x:T_1\vdash t_2 : T_2}}
\]

\[\vcenter{\infer[\textsc{T-App}]
  {\Gamma\vdash t_1\; t_2 : T_{12}}
  {\Gamma\vdash t_1 : T_{11}\rightarrow T_{12} & \Gamma\vdash t_2:T_{11}}}
\]

\[\vcenter{\infer[\textsc{T-If}]
  {\Gamma\vdash \IF t_1 \THEN t_2 \ELSE t_3 : T}
  {\Gamma\vdash t_1 : \BOOL & \Gamma\vdash t_2 : T & \Gamma\vdash t_3 : T}}
\]

\[\vcenter{\infer{\TRUE:\BOOL}{}}\]

\[\vcenter{\infer{\FALSE:\BOOL}{}}\]

Our objective is to: (i) define a data structure for representing
$\lambda_\rightarrow$ terms embodying the abstract syntax; (ii) a type
derivation function for $\lambda_\rightarrow$ terms embodying the type
rules; and (iii) an evaluation function for $\lambda_\rightarrow$
terms embodying the evaluation rules.

\section{TypedLambda Module}

\begin{code}
  module TypedLambda ( Term(..) )
      where
\end{code}

The \texttt{TypedLambda} module provides the basic definitions for
manipulating simply typed lambda calculus expressions.  The data type
representing terms and types is first defined, followed by the type
checking function and the evaluation function.

\subsection{Data Types}

An abstract type \texttt{Ty}, is defined to represent the two possible
types in $\lambda_{\rightarrow}$.  A constant represents the Boolean
type while a pair of types represents the $\rightarrow$ type former
application.  An error indicator is also included to allow the type
inference routine to return error messages.

\begin{code}
  data Ty =
      TyBool |
      TyArr Ty Ty |
      TyError String deriving (Eq,Show)

  dom :: Ty -> Ty
  dom (TyArr d _) = d
  dom TyBool = TyError "Cannot find domain of a boolean type"
  dom (TyError s) = TyError s

  ran :: Ty -> Ty
  ran (TyArr _ r) = r
  ran TyBool = TyError "Cannot find range of a boolean type"
  ran (TyError s) = TyError s

  isArr :: Ty -> Bool
  isArr (TyArr _ _) = True
  isArr TyBool = False
  isArr (TyError _) = False

  isTyError :: Ty -> Bool
  isTyError (TyError _) = True
  isTyError TyBool = False
  isTyError (TyArr _ _) = False
\end{code}

An abstract type, \texttt{Term}, is defined to represent the abstract
syntax for $\lambda_\rightarrow$ terms.  Note that this definition is
identical to that used in $\lambda$ except \texttt{Lambda} includes a
type annotation, the $\IF$ construct is defined, and boolean costants
have been added.  The implementation of the \texttt{Term} type is a
Maybe type that either represents a legal term or a form that cannot
be evaluated.

\begin{code}
  data Term = 
      TmTrue | TmFalse |         -- True and False constants
      If Term Term Term |        -- If term
      Var Int |                  -- Index number for a variable
      Lambda Ty Term |           -- Abstraction over a term with type
      App Term Term |            -- Application of term to term
      CantEval String            -- Can't evaluated the indicated form - error
      deriving (Eq,Show)

  isApp :: Term -> Bool
  isApp (App _ _) = True
  isApp (Lambda _ _) = False
  isApp (Var _) = False
  isApp (CantEval _) = False
\end{code}

The \texttt{TmTrue} and \texttt{TmFalse} values represent the Boolean
values true and false respectively.  The \texttt{If} constructor
defines a classical if-expression.  The \texttt{Var} construtor
identifies the index for a variable and corresponds with the $x$ form
in the abstract syntax.  The \texttt{Lambda} constructor defines an
abstraction by specifying a term and corresponds with the $\lambda
x:T.t$ form in the abstract syntax.  The \texttt{App} cosntructor
defines the application of one term to anothre and corresponds with
the \texttt{t t} form in the abstract syntax.  The \texttt{CantEval}
constructor identifies a form that cannot be evaluated.  It's argument
is a \texttt{String} representing the form or an error message.

The \texttt{CantEval} constructor is necessary due to the way
the evaluation function operates.  Unlike the ML implementation,
exceptions are not used to break out of an iterative evaluation
process.  Instead, the evaluation will be done recursively and the
\texttt{CantEval} constructor used to identify error situations.

The original $\lambda$ language implemented untyped lambda calculus.
Thus, the maintenance of context information was unnecessary.  For
$\lambda_\rightarrow$, the types of variables must be maintained as a
part of context for type checking.  The \texttt{Ctx} type is used to
store a list of variable bindings that will be used to maintain the
types associated with variables in context.

\begin{code}
  type Ctx = [Ty]
\end{code}

To mainipulate the context, the following functions are defined:

\begin{code}
  addBinding :: Ctx -> Ty -> Ctx
  addBinding cx t = t:cx

  getTypeFromContext :: Ctx -> Int -> Ty
  getTypeFromContext c v = c!!v
\end{code} 

\subsection{Type Derivation}

Type derivation is achieved using the \texttt{typeof} function.  Each
case directly corresponds to one of the typing rules defined for
$\lambda_\rightarrow$.

\begin{code}
  typeof :: Ctx -> Term -> Ty
  typeof ctx TmTrue = TyBool
  typeof ctx TmFalse = TyBool
  typeof ctx (If t1 t2 t3) =
      if (typeof ctx t1) == TyBool
         then let tt1 = typeof ctx t2; tt2 = typeof ctx t3 in
                  if tt1 == tt2 then tt2 else TyError "If branches of different types"
         else TyError "If conditional not boolean"
  typeof ctx (Var x) = getTypeFromContext ctx x
  typeof ctx (App t1 t2) = 
      let tt1 = typeof ctx t1; tt2 = typeof ctx t2 in
         if isArr tt1 then 
            if tt2 == dom(tt1) then tt2
               else TyError "Argument type does not match domain"
            else TyError "Term is not an abstraction"           
  typeof ctx (Lambda ty t) =
      let tt = typeof (addBinding ctx ty) t in
         (TyArr ty tt)
\end{code}

\subsection{Shifting and Substituting}

Our implementation uses de Brujin indices as a basis for
representation and evaluation.  Thus, definitions of \texttt{shift}
and \texttt{subst} are required to implement elements of the evalation
function.

The \texttt{shift} definition provides a case for shifting over each
valid $\lambda$ form as defined in the \texttt{Term} data type.  This
definition follows directly from the standard definition of shift from
TPL Chapter 8:

\begin{code}
  shift :: Term -> Int -> Int -> Term
  shift (Var x) c d = if x < c then (Var x) else (Var (x+d))
  shift (Lambda ty t) c d = (Lambda ty (shift t (c+1) d))
  shift (App t1 t2) c d = (App (shift t1 c d) (shift t2 c d))
\end{code}

Both \texttt{Lambda} and \texttt{App} terms are shifted by shifting
their identified terms.  Shifting a \texttt{Var} term requires
application of the definition from Chapter 8.  Specifically, the index
for a variable is shifted by \texttt{d} if its index is greater than
\texttt{c}.

The \texttt{subst} definition again provides a case for substitution
over each value $\lambda$ for as defined in the \texttt{Term} data
type.  This definition follows directly from teh standard definition
of substitution from TPL Chapter 8:

\begin{code}
  subst :: Int -> Term -> Term -> Term
  subst j s (Var x) = if x==j then s else (Var x)
  subst j s (Lambda ty t) = (Lambda ty (subst (j+1) (shift s 0 1) t))
  subst j s (App t1 t2) = (App (subst j s t1) (subst j s t2))
\end{code}

\subsection{Call By Value Evaluation Function}

The \texttt{evalValue} function provides a standard definition of
call-by-value evaluation following from TPL Chapter 5.  The function
definition is split up into cases corresponding to the evaluation
rules.  Note that only \texttt{App} forms can be evaluated.
\texttt{Lambda} forms are values and \texttt{Var} forms are not
closed.  Although passing a context is allowed in this function, in
this project we are concerned only with close terms.  Thus, the
context can be safely ignored in all evaluation cases.

The form of the evaluation function is a mapping from \texttt{Ctx} and
\texttt{Term} to another \texttt{Term}

\begin{code}
  evalValue :: Ctx -> Term -> Term
\end{code}

The first case to handle is \textsc{E-AppAbs} that evaluates an
application.  Both terms in the abstraction must be values.  Because
all \texttt{Lambda} forms are values, pattern matching is used to
assure values for this particular case.  The definition of evaluation
is taken directly from TPL Chapters 7 and 8:

\begin{code}
  evalValue _ (App (Lambda ty12 t12) (Lambda ty2 v2)) =
        let nt = shift (subst 0 (shift (Lambda ty2 v2) 0 1) t12) 0 (-1) in
            if (isApp nt) then evalValue [] nt else nt
\end{code}

The evaluation rule \textsc{E-App1} is used when the first term of the
application is not a value.  It is handled by two subcases
corresponding with \texttt{App} and \texttt{Var} forms.  In the first
subcase, the first term is an application and is evaluated before
evaluating the outer application.  In the second subcase, the first
term is a variable and is again evaluation before evaluating the outer
application.

\begin{code}
  evalValue c (App (App t11 t12) t) =
      let nt = evalValue c (App t11 t12) in evalValue c (App nt t)
  evalValue c (App (Var x) t) = 
      let nt = evalValue c (Var x) in evalValue c (App nt t)
\end{code}

The second subcase will always lead to an error in this
implementation, but future implementations will not have this
restriction.  Thus, it is defined strictly rather than taking a
shortcut to the error generation.

The evaluation rule \textsc{E-App2} is used when the first term of the
application is a value, but the second is not.  It is again handled by
two subcases that correspond to the same cases as \textsc{E-App1},
except the second term is being evaluated:

\begin{code}
  evalValue c (App (Lambda ty12 t12) (App t21 t22)) =
      let nt = evalValue c (App t21 t22) in evalValue c (App t21 nt)
  evalValue c (App (Lambda ty12 t12) (Var x)) = 
      evalValue c (App (Lambda ty12 t12) (evalValue c (Var x)))
\end{code}

The previous cases of \texttt{evalValue} account for the successful
application of evaluation rules.  However, error cases and the case
for evaluating values remain to be defined.

In $\lambda_\rightarrow$, the boolean constants $\TRUE$ and $\FALSE$ in
addition to all lambda expressions are treated as values.  By
definition, a value cannot be further evaluated.  Thus, evaluating a
\texttt{Lambda} form, $\TRUE$, or $\FALSE$ results in the value itself:

\begin{code}
  evalValue _ (Lambda ty t) = (Lambda ty t)
  evalValue _ TmTrue = TmTrue
  evalValue _ TmFalse = TmFalse
\end{code}

Three additional cases define the evaluation of the $\IF$ form.  If
the conditional is a value, then the $\IF$ form reduces to its
appropriate form.  I will follow strictly the evaluation rules from
Chapter 3 Figure 3-1 that do not define the evaluation of the $\IF$
form in the strictest possible manner.

\begin{code}
  evalValue _ (If TmTrue t2 _) = t2
  evalValue _ (If TmFalse _ t3) = t3
  evalValue c (If (App t11 t12) t2 t3) = 
    (If (evalValue c (App t11 t12)) t2 t3)
\end{code}

With the evaluation of values defined, the only remaining issue is the
error case caused when a free variable is evaluated.  Three cases of
\texttt{evalValue} handle the generation of the error and propagation
back through the recursive invocation of \texttt{evalValue}:

\begin{code}
  evalValue _ (Var x) = (CantEval (show (Var x)))
  evalValue _ (App (CantEval x) t) = (CantEval x)
  evalValue _ (App t (CantEval x)) = (CantEval x)
\end{code}

The first case generates the error when a free variable is evaluated.
It converts the variable into a string and uses the \texttt{CantEval}
constructor to generate an error.  The error is propagated back
through the recursion using the two following cases.  Together they
state that the result of evaluating an \texttt{App} is
\texttt{CantEval} if either of its terms are \texttt{CantEval}.

\subsection{Call By Name Evaluation Function}

Call-by-name evaluation uses the same definition of terms and values
as call-by-value.  However, two different evaluation rules define the
evaluation relation:

\[\vcenter{\infer[\textsc{E-App1}]{t_1 t_2 \longrightarrow t_1^{'} t_2}{t_1\longrightarrow t_1^{'}}}\]

\[\vcenter{\infer[\textsc{E-AppAbs}]{(\lambda x.t_{12})t_2 \longrightarrow [x\rightarrow t_2]t_{12}}{}}\]

The \textsc{E-App1} rule is identical to the rule for call-by-value.
However, the \textsc{E-AppAbs} rule does not require the argument to
the \texttt{Lambda} to be a value and the old \textsc{E-App2}
evaluation rule is no longer needed.

The \texttt{evalLazy} function provides a standard definition of
call-by-name evaluation following from TPL problem solutions.  The
function definition is split up into cases corresponding to the
evaluation rules identically to \texttt{evalValue}.  Again, only
\texttt{App} forms can be evaluated, \texttt{Lambda} forms are values
and \texttt{Var} forms are not closed and thus not considered.

\begin{code}
  evalLazy :: Ctx -> Term -> Term
\end{code}

Again, the first case to handle is \textsc{E-AppAbs} that evaluates an
application.  The first term must be a value.  In call-by-name
evaluation, it is not necessary for the second term to be a value.
Thus, the pattern match to assure that the second term is a
\texttt{Lambda} is removed.  The definition of evaluation is taken
directly from TPL Chapters 7 and 8:

\begin{code}
  evalLazy _ (App (Lambda ty12 t12) t2) =
     let nt = shift (subst 0 (shift t2 0 1) t12) 0 (-1) in
         if (isApp nt) then (evalLazy [] nt) else nt
\end{code}

The second and third cases occur when the first \texttt{App} term is
not a value.  The first case handles when the first term is an
\texttt{App} form and the second when the first term is a \texttt{Var}
form.  These cases are virtually identical to those for call-by-value.

\begin{code}
  evalLazy c (App (App t11 t12) t) =
      let nt = evalLazy c (App t11 t12) in evalLazy c (App nt t)
  evalLazy c (App (Var x) t) = 
      let nt = evalLazy c (Var x) in evalLazy c (App nt t)
\end{code}

Both cases for \textsc{E-App2} from the call-by-value implementation
are no longer needed because the \textsc{E-App2} rule is gone.  The
\textsc{E-AppAbs} cases will match when \textsc{E-App2} used to
because the second term in the \texttt{App} need not be a value.

Like call-by-value, \texttt{Lambda} forms, \texttt{true} and
\texttt{false} are values.  Thus, evaluating them in the call-by-name
scheme is identical to call-by-value.

\begin{code}
  evalLazy _ (Lambda ty t) = (Lambda ty t)
  evalLazy _ TmTrue = TmTrue
  evalLazy _ TmFalse = TmFalse
\end{code}

Three additional cases define the evaluation of the $\IF$ form that
are identical to thos for call-by-value.  If the conditional is a
value, then the $\IF$ form reduces to its appropriate form.

\begin{code}
  evalLazy _ (If TmTrue t2 _) = t2
  evalLazy _ (If TmFalse _ t3) = t3
  evalLazy _ (If (App t11 t12) t2 t3) = 
    (If (evalLazy _ (App t11 t12)) t2 t3)
\end{code}

Error cases for call-by-name are a subset of error cases for
call-by-value.  Evaluating a free variable still generates an error
and an error occuring during evaluation of the first \texttt{App} term
is propagated back.  However, in call-by-name evaluation the second
term is not evaluated until necessary and the error case from
call-by-value does not occur.

\begin{code}
  evalLazy _ (Var x) = (CantEval (show (Var x)))
  evalLazy _ (App (CantEval x) t) = (CantEval x)
\end{code}

\section{Type Checking and Evaluation}

The objective of type checking is to statically predict the runtime
behavior of a code element with respect to the kinds of values
produced and expected.  Specifically, does a program element always
product the kind of value espected.  Th e \texttt{typeof} function
provides a capability for generating the type associated with a
$\lambda_\rightarrow$ term.  If such a type exists, then the term is
well-typed and should be executed.

To combine type checking and evaluation is a simple matter of: (i)
determining the type of a term; and (ii) executing the term if the
type exists.  This process can be specified using the following
template:

\begin{code}
  evalTemplate :: (Term -> Ty) -> (Term -> Term) -> Term -> Term
  evalTemplate typeof eval t =
    let tt = (typeof t) in
	if (isTyError tt) then (errorToTerm tt) else (eval t)

  errorToTerm :: Ty -> Term
  errorToTerm (TyError s) = CantEval s
\end{code}

The \texttt{errorToTerm} function is needed to convert a type checking
error to an evaluation error.  The generated error message is simply
pulled out of the type error structure and returned in a run-time
error structure.

With the template defined, call-by-value and call-by-name evaluation
functions are defined as follows:

\begin{code}
  evalV :: Term -> Term
  evalV = evalTemplate (typeof []) (evalValue [])

  evalL :: Term -> Term
  evalL = evalTemplate (typeof []) (evalLazy [])
\end{code}

In both cases, the \texttt{evalTemplate} function is curried with the
type checking and evaluation functions

\section{Testing and Evaluation}

To test the interpreter, some functions from the book are provided
here.  They include the identity combinator, Church Boolean funtions,
some Church Numbers and the successor function defined for Church
numbers.

\begin{code}
  ident :: Term
  ident = (Lambda TyBool (Var 0))
\end{code}

Church Boolean definitions:

\begin{code}
  tru :: Term
  tru = (Lambda TyBool (Lambda TyBool (Var 1)))
  fls :: Term
  fls = (Lambda TyBool (Lambda TyBool (Var 0)))
\end{code}

Church Number definitions:

\begin{code}
  c0 :: Term
  c0 = (Lambda TyBool (Lambda TyBool (Var 0)))

  c1 :: Term
  c1 = (Lambda TyBool (Lambda TyBool (App (Var 1) (Var 0))))

  c2 :: Term
  c2 = (Lambda TyBool (Lambda TyBool (App (Var 1) (App (Var 1) (Var 0)))))

  scc :: Term
  scc = (Lambda TyBool
         (Lambda TyBool
          (Lambda TyBool (App (Var 1)
                          (App (Var 2)
                           (App (Var 1) (Var 0)))))))
\end{code}

Tests to try on Church Booleans:

\begin{code}
  testTru :: Term
  testTru = (App (App tru ident) fls)

  testFls :: Term
  testFls = (App (App fls fls) ident)
\end{code}

Omega:

\begin{code}
  omega :: Term
  omega = (Lambda TyBool (App (Var 0) (Var 0)))
\end{code}

\end{document}
