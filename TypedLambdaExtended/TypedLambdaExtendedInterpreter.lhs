\section{Interpretation}

Here the type checker and the evaluator are put together to form an
interpreter.

\begin{code}
  module TypedLambdaExtendedInterpreter where

  import LangUtils
  import TypedLambdaExtendedEnv
  import TypedLambdaExtendedAST
  import TypedLambdaExtendedEval
  import TypedLambdaExtendedTypesT
\end{code}

The |interpret| function is primarily a command line, testing
function.  It accepts a term and generates an |IO| monad representing
either the error message or value generated by the evaluator.  Most of
the work here is simply getting the output in a reasonably well
formatted form.

\begin{code}
  interpret :: TmLang -> IO ()
  interpret t = case (runTypeof t) of
		(Left (TypedLambdaExtendedTypesT.Err y)) ->
		    do{ putStr "Type Error: "
		      ; putStr y; putStr "\n"
		      }
		(Right y) -> case (runEval t []) of
			    (Left (TypedLambdaExtendedEval.Err z)) ->
				do{ putStr "Runtime Error: "
				  ; putStr (show z)
				  ; putStr "\n"
				  }
			    (Right z) ->
				do{ putStr "Value: "
				  ; putStr (show z)
				  ; putStr " :: "
				  ; putStr (show y)
				  ; putStr "\n"
				  }
\end{code}

The following are little utility functions that make writing
expressions in the term language easier.

\begin{code}
  numT x = toTmLang (TmConstInt x)
  varT x = toTmLang (TmVar x)
  addT x y = toTmLang (TmAdd x y)
  subT x y = toTmLang (TmSub x y)
  mulT x y = toTmLang (TmMul x y)
  divT x y = toTmLang (TmDiv x y)
  appT x y = toTmLang (TmApp x y)
  lambdaT x y z = toTmLang (TmLambda x y z)
  ifT x y z = toTmLang (If x y z)
  tupleT vs = toTmLang (TmTuple vs)
  prjT t i = toTmLang (TmPrj t i)

  intTy = (toTyLang TyInt)
  boolTy = (toTyLang TyBool)
  lambdaTy t1 t2 = (toTyLang (t1 :->: t2))
  tupleTy ts = (toTyLang (TyTuple ts))

  identT = lambdaT "x" intTy (varT "x")
\end{code}

The following are examples that can be used to test basic
functionality of the interpreter.  They can all be interpreted using
the |inerpret| function on the example name.

\begin{code}
  t0 = (addT (numT 1) (numT 3)) -- Add 1 and 3
  t1 = (divT (numT 1) (numT 1)) -- Divide 1 and 1
  t2 = (divT (numT 1) (numT 0)) -- Error - Division by 0

  t3 = identT
  t4 = appT identT (numT 1) -- Apply ident to 1
  t5 = appT identT (toTmLang TmTrue) -- Apply ident to True - Error bad type
  t6 = appT (lambdaT "x" intTy -- Two parameter function using nested lambdas
	     (appT (lambdaT "y" intTy
		    (addT (varT "x") (varT "y")))
	      (numT 1))) -- Apply to 1 and 2 to get 3
       (numT 2)

  t7 = prjT 0 (tupleT [(numT 1),toTmLang TmTrue]) -- Project out of tuple
  t8 = prjT 1 (tupleT [(numT 1),toTmLang TmTrue]) -- Project out of tuple
  t9 = prjT 2 (tupleT [(numT 1),toTmLang TmTrue]) -- Error - index out of range

  t10 = ifT t8 t7 (numT 5) -- if over two projects (t8 and t7) and 5
  t11 = ifT t7 t8 (toTmLang TmFalse) -- if with type error - t7 not boolean
  t12 = ifT t8 t7 t8 -- if with type error - t7 and t8 of different types

  t13 = appT (lambdaT "b" boolTy -- if and projection in lambda
	      (ifT (varT "b") t7 (numT 5))) 
             (toTmLang TmTrue)
  t14 = appT (lambdaT "b" boolTy -- select the other case
	      (ifT (varT "b") t7 (numT 5)))
             (toTmLang TmFalse)

  t15 = appT (lambdaT "f" (lambdaTy intTy intTy) -- Name ident "f" and apply it
	      (appT (varT "f") (numT 5))) identT

  t16 = appT (lambdaT "x" intTy -- Pass in function and number and apply
	      (appT (lambdaT "f" (lambdaTy intTy intTy)
		     (appT (varT "f") (varT "x")))
	       identT))
        (numT 5)

  t17 = appT (lambdaT "x" intTy -- Same as above with type error
	      (appT (lambdaT "f" (lambdaTy intTy boolTy)
		     (appT (varT "f") (varT "x")))
	       identT))
        (numT 5)
\end{code}